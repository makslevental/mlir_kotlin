// Generated by jextract

package org.mlir;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class MlirExternalPassCallbacks {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("construct"),
        Constants$root.C_POINTER$LAYOUT.withName("destruct"),
        Constants$root.C_POINTER$LAYOUT.withName("initialize"),
        Constants$root.C_POINTER$LAYOUT.withName("clone"),
        Constants$root.C_POINTER$LAYOUT.withName("run")
    ).withName("MlirExternalPassCallbacks");
    public static MemoryLayout $LAYOUT() {
        return MlirExternalPassCallbacks.$struct$LAYOUT;
    }
    static final FunctionDescriptor construct$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle construct$MH = RuntimeHelper.downcallHandle(
        MlirExternalPassCallbacks.construct$FUNC
    );
    public interface construct {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(construct fi, MemorySession session) {
            return RuntimeHelper.upcallStub(construct.class, fi, MlirExternalPassCallbacks.construct$FUNC, session);
        }
        static construct ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    MlirExternalPassCallbacks.construct$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle construct$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("construct"));
    public static VarHandle construct$VH() {
        return MlirExternalPassCallbacks.construct$VH;
    }
    public static MemoryAddress construct$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.construct$VH.get(seg);
    }
    public static void construct$set( MemorySegment seg, MemoryAddress x) {
        MlirExternalPassCallbacks.construct$VH.set(seg, x);
    }
    public static MemoryAddress construct$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.construct$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void construct$set(MemorySegment seg, long index, MemoryAddress x) {
        MlirExternalPassCallbacks.construct$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static construct construct (MemorySegment segment, MemorySession session) {
        return construct.ofAddress(construct$get(segment), session);
    }
    static final FunctionDescriptor destruct$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle destruct$MH = RuntimeHelper.downcallHandle(
        MlirExternalPassCallbacks.destruct$FUNC
    );
    public interface destruct {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(destruct fi, MemorySession session) {
            return RuntimeHelper.upcallStub(destruct.class, fi, MlirExternalPassCallbacks.destruct$FUNC, session);
        }
        static destruct ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    MlirExternalPassCallbacks.destruct$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle destruct$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("destruct"));
    public static VarHandle destruct$VH() {
        return MlirExternalPassCallbacks.destruct$VH;
    }
    public static MemoryAddress destruct$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.destruct$VH.get(seg);
    }
    public static void destruct$set( MemorySegment seg, MemoryAddress x) {
        MlirExternalPassCallbacks.destruct$VH.set(seg, x);
    }
    public static MemoryAddress destruct$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.destruct$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void destruct$set(MemorySegment seg, long index, MemoryAddress x) {
        MlirExternalPassCallbacks.destruct$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static destruct destruct (MemorySegment segment, MemorySession session) {
        return destruct.ofAddress(destruct$get(segment), session);
    }
    static final FunctionDescriptor initialize$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(
        Constants$root.C_CHAR$LAYOUT.withName("value")
    ).withName("MlirLogicalResult"),
        MemoryLayout.structLayout(
            Constants$root.C_POINTER$LAYOUT.withName("ptr")
        ).withName("MlirContext"),
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle initialize$MH = RuntimeHelper.downcallHandle(
        MlirExternalPassCallbacks.initialize$FUNC
    );
    public interface initialize {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(initialize fi, MemorySession session) {
            return RuntimeHelper.upcallStub(initialize.class, fi, MlirExternalPassCallbacks.initialize$FUNC, session);
        }
        static initialize ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.MemorySegment)MlirExternalPassCallbacks.initialize$MH.invokeExact((Addressable)symbol, __x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle initialize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("initialize"));
    public static VarHandle initialize$VH() {
        return MlirExternalPassCallbacks.initialize$VH;
    }
    public static MemoryAddress initialize$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.initialize$VH.get(seg);
    }
    public static void initialize$set( MemorySegment seg, MemoryAddress x) {
        MlirExternalPassCallbacks.initialize$VH.set(seg, x);
    }
    public static MemoryAddress initialize$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.initialize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void initialize$set(MemorySegment seg, long index, MemoryAddress x) {
        MlirExternalPassCallbacks.initialize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static initialize initialize (MemorySegment segment, MemorySession session) {
        return initialize.ofAddress(initialize$get(segment), session);
    }
    static final FunctionDescriptor clone$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle clone$MH = RuntimeHelper.downcallHandle(
        MlirExternalPassCallbacks.clone$FUNC
    );
    public interface clone {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(clone fi, MemorySession session) {
            return RuntimeHelper.upcallStub(clone.class, fi, MlirExternalPassCallbacks.clone$FUNC, session);
        }
        static clone ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.clone$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle clone$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("clone"));
    public static VarHandle clone$VH() {
        return MlirExternalPassCallbacks.clone$VH;
    }
    public static MemoryAddress clone$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.clone$VH.get(seg);
    }
    public static void clone$set( MemorySegment seg, MemoryAddress x) {
        MlirExternalPassCallbacks.clone$VH.set(seg, x);
    }
    public static MemoryAddress clone$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.clone$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void clone$set(MemorySegment seg, long index, MemoryAddress x) {
        MlirExternalPassCallbacks.clone$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static clone clone (MemorySegment segment, MemorySession session) {
        return clone.ofAddress(clone$get(segment), session);
    }
    static final FunctionDescriptor run$FUNC = FunctionDescriptor.ofVoid(
        MemoryLayout.structLayout(
            Constants$root.C_POINTER$LAYOUT.withName("ptr")
        ).withName("MlirOperation"),
        MemoryLayout.structLayout(
            Constants$root.C_POINTER$LAYOUT.withName("ptr")
        ).withName("MlirExternalPass"),
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle run$MH = RuntimeHelper.downcallHandle(
        MlirExternalPassCallbacks.run$FUNC
    );
    public interface run {

        void apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(run fi, MemorySession session) {
            return RuntimeHelper.upcallStub(run.class, fi, MlirExternalPassCallbacks.run$FUNC, session);
        }
        static run ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    MlirExternalPassCallbacks.run$MH.invokeExact((Addressable)symbol, __x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle run$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("run"));
    public static VarHandle run$VH() {
        return MlirExternalPassCallbacks.run$VH;
    }
    public static MemoryAddress run$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.run$VH.get(seg);
    }
    public static void run$set( MemorySegment seg, MemoryAddress x) {
        MlirExternalPassCallbacks.run$VH.set(seg, x);
    }
    public static MemoryAddress run$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)MlirExternalPassCallbacks.run$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void run$set(MemorySegment seg, long index, MemoryAddress x) {
        MlirExternalPassCallbacks.run$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static run run (MemorySegment segment, MemorySession session) {
        return run.ofAddress(run$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


